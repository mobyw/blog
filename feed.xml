<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
  <channel>
    <title>Xiaohei Terminal</title>
    <link>https://xiaohei.moe/feed.xml</link>
    <description>Xiaohei's blog</description>
    <atom:link href="https://xiaohei.moe/feed.xml" rel="self"/>
    <docs>http://www.rssboard.org/rss-specification</docs>
    <generator>python-feedgen</generator>
    <lastBuildDate>Sun, 22 Sep 2024 10:57:55 +0000</lastBuildDate>
    <item>
      <title>使用开发平台 API 下载华为云空间文件历史版本</title>
      <link>https://xiaohei.moe/post/2023/03/13/huawei-drive-file-history/</link>
      <description><![CDATA[<p>近日有一个回退华为云空间文件版本的需求。虽然客户端上没有恢复版本文件的入口，但在华为开发者联盟上提供了查询文件历史版本的 <a href="https://developer.huawei.com/consumer/cn/doc/development/HMSCore-Guides/server-quaring-history-version-0000001064501116">API</a> ，故尝试使用该 API 获取文件的历史版本。</p>
<h2>准备工作</h2>
<p>注册华为开发者联盟账号后，需要完成实名认证，并在管理后台创建一个 AppGallery Connect 项目：</p>
<p><img alt="项目创建" src="https://s2.loli.net/2023/03/13/qQvK7R4ftu9jCXU.png" /></p>
<p>在该项目下创建一个应用，只需填写第一步的信息：</p>
<p><img alt="应用创建" src="https://s2.loli.net/2023/03/13/zb6KhOv2T3PcIBp.png" /></p>
<p>创建应用后回到项目页面，在 <code>API管理</code> 标签下打开 <code>云空间</code> 选项：</p>
<p><img alt="云空间权限使能" src="https://s2.loli.net/2023/03/13/IwJjXcuExHF4p7a.png" /></p>
<p>在应用页面 <code>常规</code> 标签下找到 <code>应用</code> 栏，添加回调地址，可以使用一个不存在的网站：</p>
<p><img alt="获取应用信息" src="https://s2.loli.net/2023/03/13/aTjbAuXpvMwDQfN.png" /></p>
<p>记录下 <code>Client ID</code> 和 <code>Client Secret</code>。</p>
<h2>获取 Access token</h2>
<p>此部分参考 <a href="https://developer.huawei.com/consumer/cn/doc/development/HMSCore-Guides/open-platform-oauth-0000001053629189">基于 OAuth 2.0 开放鉴权</a> 中的 <code>授权码扩展模式（PKCE）</code> 部分。</p>
<p>访问：</p>
<p><a href="https://oauth-login.cloud.huawei.com/oauth2/v3/authorize?response_type=code&amp;code_challenge=ovoy4lehgHbv8uNmif_hak3bH2_Ylk6_fWP0UL232QQ&amp;code_challenge_method=plain&amp;client_id={{client_id}}&amp;redirect_uri={{redirect_uri}}&amp;scope=openid+https://www.huawei.com/auth/drive">https://oauth-login.cloud.huawei.com/oauth2/v3/authorize?response_type=code&amp;code_challenge=ovoy4lehgHbv8uNmif_hak3bH2_Ylk6_fWP0UL232QQ&amp;code_challenge_method=plain&amp;client_id={{client_id}}&amp;redirect_uri={{redirect_uri}}&amp;scope=openid+https://www.huawei.com/auth/drive</a></p>
<p>将 <code>client_id</code> 替换为准备工作中获取的 <code>Client ID</code>，<code>redirect_uri</code> 替换为准备工作中填写的回调地址。</p>
<p>访问后回跳转到回调地址，参数为 <code>?code=...</code>，记录 <code>code</code> 的内容，作为授权码 Code。</p>
<p>然后需要通过此授权码 Code 换取鉴权令牌：</p>
<pre class="highlight"><code class="language-http">### Get access token by authorization code
POST https://oauth-login.cloud.huawei.com/oauth2/v3/token HTTP/1.1
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&amp;
code={{code}}&amp;
client_id={{client_id}}&amp;
client_secret={{client_secret}}&amp;
code_verifier=ovoy4lehgHbv8uNmif_hak3bH2_Ylk6_fWP0UL232QQ&amp;
redirect_uri={{redirect_uri}}
</code></pre>

<p>填写 <code>code</code> <code>client_id</code> <code>client_secret</code> <code>redirect_uri</code>，注意 <code>code</code> 需要进行 URL 编码。发送请求，获得的结果如下：</p>
<pre class="highlight"><code class="language-json">{
  &quot;scope&quot;: &quot;https://www.huawei.com/auth/drive openid&quot;,
  &quot;access_token&quot;: &quot;DA************&quot;,
  &quot;token_type&quot;: &quot;Bearer&quot;,
  &quot;expires_in&quot;: 3600,
  &quot;id_token&quot;: &quot;...&quot;
}
</code></pre>

<p>记录 <code>access_token</code> 内容，在后续步骤中验证使用。</p>
<h2>恢复文件</h2>
<p>此部分参考 <a href="https://developer.huawei.com/consumer/cn/doc/development/HMSCore-Guides/server-quaring-history-version-0000001064501116">查询文件历史版本</a> 。</p>
<p>首先需要获取文件 <code>id</code>，如果文件较少可直接获取全部文件列表：</p>
<pre class="highlight"><code class="language-http">### Get file list
GET https://driveapis.cloud.huawei.com.cn/drive/v1/files?fields=* HTTP/1.1
Accept: application/json
Cache-Control: no-cache
Authorization: Bearer {{access_token}}
</code></pre>

<p>如果文件较多可以参考 <a href="https://developer.huawei.com/consumer/cn/doc/development/HMSCore-References/server-public-info-0000001050159641">文档</a> 中 <code>mimeType</code> 的介绍进行搜索与排序，下面是一个按编辑日期倒序排序 <code>.docx</code> 文件的示例：</p>
<pre class="highlight"><code class="language-http">### Get `.docx` file list ordered by editedTime desc
GET https://driveapis.cloud.huawei.com.cn/drive/v1/files?fields=*&amp;queryParam=mimeType%3D%27application%2Fvnd.openxmlformats-officedocument.wordprocessingml.document%27&amp;orderBy=editedTime%20desc HTTP/1.1
Content-Type: application/json
Authorization: Bearer {{access_token}}
Cache-Control: no-cache
Accept: application/json
</code></pre>

<p>测试时该接口经常提示无权限，但多次访问后又会正常返回，如果配置信息正确仍提示 <code>INSUFFICIENT_SCOPE</code> 就多试几次。</p>
<p>返回结果格式如下：</p>
<pre class="highlight"><code class="language-json">{
  &quot;files&quot;: [
    {
      &quot;fileName&quot;: &quot;测试.doc&quot;,
      &quot;sha256&quot;: &quot;30e0ee3fc2ac07ca2e2fedfa4aad5a293c13a28268f4843f354f2675f78f991d&quot;,
      &quot;fileSuffix&quot;: &quot;doc&quot;,
      &quot;mimeType&quot;: &quot;application/octet-stream&quot;,
      &quot;lastHistoryVersionId&quot;: &quot;1110774401038742656.1110774800504128256&quot;,
      &quot;editedByMeTime&quot;: &quot;2023-03-13T05:51:14.000Z&quot;,
      &quot;createdTime&quot;: &quot;2023-03-13T05:50:27.166Z&quot;,
      &quot;id&quot;: &quot;BoAY1s_TPZKYqq3HJGUtObq9sd5VZTUUm&quot;,
      &quot;version&quot;: 5,
      &quot;iconDownloadLink&quot;: &quot;https://event.dbankcdn.com/filemanagerpic/20191114101425c162.png&quot;,
      &quot;editedTime&quot;: &quot;2023-03-13T05:51:14.000Z&quot;,
      &quot;size&quot;: 38912,
      &quot;fullFileSuffix&quot;: &quot;doc&quot;,
      &quot;category&quot;: &quot;drive#file&quot;
    },
    {
      // ...
    }
  ],
  &quot;category&quot;: &quot;drive#fileList&quot;
}
</code></pre>

<p>找到对应的文件并记录其 <code>id</code>，然后获取其历史记录：</p>
<pre class="highlight"><code class="language-http">### Get file history
GET https://driveapis.cloud.huawei.com.cn/drive/v1/files/{{id}}/historyVersions?fields=* HTTP/1.1
Authorization: Bearer {{access_token}}
Cache-Control: no-cache
Accept: application/json
</code></pre>

<p>返回结果如下：</p>
<pre class="highlight"><code class="language-json">{
  &quot;historyVersions&quot;: [
    {
      &quot;editedTime&quot;: &quot;2023-03-13T05:51:15.063Z&quot;,
      &quot;size&quot;: 38912,
      &quot;sha256&quot;: &quot;ce6376d16144b5c36da0414a4666a33bb15624f8b5c0553dad1ae456c64510ac&quot;,
      &quot;id&quot;: &quot;1110774401038742656.1110774800504128256&quot;,
      &quot;mimeType&quot;: &quot;application/octet-stream&quot;,
      &quot;category&quot;: &quot;drive#historyVersion&quot;,
      &quot;originalFilename&quot;: &quot;nonamea696f86cb6e045d19c696396636595b5&quot;
    },
    {
      // ...
    },
    {
      // ...
    }
  ],
  &quot;category&quot;: &quot;drive#historyVersionList&quot;
}
</code></pre>

<p>根据编辑时间找到需要的版本（UTC 时间），记录下历史文件的 <code>id</code>，由于和文件 <code>id</code> 重名，在下面表示为 <code>history_id</code>。直接下载对应历史版本文件：</p>
<pre class="highlight"><code class="language-http">### Get file
GET https://driveapis.cloud.huawei.com.cn/drive/v1/files/{{id}}/historyVersions/{{history_id}}?form=content HTTP/1.1
Authorization: Bearer {{access_token}}
Cache-Control: no-cache
Accept: application/json
</code></pre>]]></description>
      <guid isPermaLink="false">https://xiaohei.moe/post/2023/03/13/huawei-drive-file-history/</guid>
      <pubDate>Mon, 13 Mar 2023 13:44:00 +0806</pubDate>
    </item>
    <item>
      <title>不同高级语言的 URL 编码差异</title>
      <link>https://xiaohei.moe/post/2023/08/07/url-encode-differentiation/</link>
      <description><![CDATA[<p>水群时看到有群友遇到了因 URL 对字符 <code>*</code> 的编码不符合预期问题导致的程序错误，便做此篇测试部分高级语言的 URL 编码实现有何不同。</p>
<h2>相关标准</h2>
<p>由于 <a href="https://datatracker.ietf.org/doc/html/rfc1738">RFC 1738: Uniform Resource Locators (URL)</a> 并非互联网标准 (Internet Standard)，故本文参考互联网标准 <a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3986: Uniform Resource Identifier (URI): Generic Syntax</a> 编写。该标准推荐使用通用术语 "URI"，而不是限制性更强的术语 "URL" 和 "URN" <a href="https://datatracker.ietf.org/doc/html/rfc3305">(RFC3305)</a>。</p>
<p>RFC 3986 对 URI 中非保留字符的定义如下：</p>
<pre class="highlight"><code class="language-text">unreserved  = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;
</code></pre>

<p>在 URI 编码时，对于非保留字符 <code>unreserved</code> 应保持不进行转义，但是该标准同样说明了如果遇到了转义了这些字符的 URI 编码，在解码时仍需要将其恢复为原字符。</p>
<pre class="highlight"><code class="language-text">URIs that differ in the replacement of an unreserved character with
its corresponding percent-encoded US-ASCII octet are equivalent: they
identify the same resource.  However, URI comparison implementations
do not always perform normalization prior to comparison (see Section
6).  For consistency, percent-encoded octets in the ranges of ALPHA
(%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E),
underscore (%5F), or tilde (%7E) should not be created by URI
producers and, when found in a URI, should be decoded to their
corresponding unreserved characters by URI normalizers.
</code></pre>

<p>该标准中同样指出了 <code>~</code> 字符在旧的 URI 编码实现中经常转义为 <code>%7E</code>。</p>
<pre class="highlight"><code class="language-text">For example, the octet
corresponding to the tilde (&quot;~&quot;) character is often encoded as &quot;%7E&quot;
by older URI processing implementations; the &quot;%7E&quot; can be replaced by
&quot;~&quot; without changing its interpretation.
</code></pre>

<p>对于可能需要转义的保留字符，该标准将其分为两类：</p>
<pre class="highlight"><code class="language-text">reserved    = gen-delims / sub-delims
gen-delims  = &quot;:&quot; / &quot;/&quot; / &quot;?&quot; / &quot;#&quot; / &quot;[&quot; / &quot;]&quot; / &quot;@&quot;
sub-delims  = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;'&quot; / &quot;(&quot; / &quot;)&quot;
            / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot;
</code></pre>

<p>其中 <code>gen-delims</code> 和 URI 的结构相关，必须要进行转义，而 <code>sub-delims</code> 是否需要需要根据所在位置判断。特别地，由于转义使用 <code>%</code> 符号，所以 <code>%</code> 符号自身也需要进行转义。</p>
<p>典型的 URI 组成部分如下：</p>
<pre class="highlight"><code class="language-text">      foo://example.com:8042/over/there?name=ferret#nose
      \_/   \______________/\_________/ \_________/ \__/
       |           |            |            |        |
    scheme     authority       path        query   fragment
       |   _____________________|__
      / \ /                        \
      urn:example:animal:ferret:nose
</code></pre>

<p>与 <code>sub-delims</code> 相关的文法片段如下：</p>
<pre class="highlight"><code class="language-text">authority     = [ userinfo &quot;@&quot; ] host [ &quot;:&quot; port ]
userinfo      = *( unreserved / pct-encoded / sub-delims / &quot;:&quot; )

host          = IP-literal / IPv4address / reg-name
IP-literal    = &quot;[&quot; ( IPv6address / IPvFuture  ) &quot;]&quot;
IPvFuture     = &quot;v&quot; 1*HEXDIG &quot;.&quot; 1*( unreserved / sub-delims / &quot;:&quot; )
reg-name      = *( unreserved / pct-encoded / sub-delims )

path          = path-abempty    ; begins with &quot;/&quot; or is empty
              / path-absolute   ; begins with &quot;/&quot; but not &quot;//&quot;
              / path-noscheme   ; begins with a non-colon segment
              / path-rootless   ; begins with a segment
              / path-empty      ; zero characters
path-abempty  = *( &quot;/&quot; segment )
path-absolute = &quot;/&quot; [ segment-nz *( &quot;/&quot; segment ) ]
path-noscheme = segment-nz-nc *( &quot;/&quot; segment )
path-rootless = segment-nz *( &quot;/&quot; segment )
path-empty    = 0&lt;pchar&gt;
segment       = *pchar
segment-nz    = 1*pchar
segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / &quot;@&quot; )
              ; non-zero-length segment without any colon &quot;:&quot;
pchar         = unreserved / pct-encoded / sub-delims / &quot;:&quot; / &quot;@&quot;

query         = *( pchar / &quot;/&quot; / &quot;?&quot; )

fragment      = *( pchar / &quot;/&quot; / &quot;?&quot; )
</code></pre>

<p>如果按照以上文法推导，<code>sub-delims</code> 中的字符在 <code>authority</code> <code>path</code> <code>query</code> <code>fragment</code> 中均可能保持原样。</p>
<p>另外，空格字符在 <code>application/x-www-form-urlencoded</code> 类型中编码为 <code>+</code>，而在 RFC 3986 中的编码为 <code>%20</code>。</p>
<p>为找出不同高级语言对这些字符转义处理的差别，下面进行了一个简单的测试，先给出了测试结果，具体的测试代码及输出在最后给出。</p>
<h2>测试结果</h2>
<p>仅测试了在 <code>query</code> 段中的编码和解码情况，在所有编码测试中，以 <code>sub-delims</code> 中的字符均已编码，<code>unreserved</code> 中的特殊字符均未编码为参考结果，标注与参考结果有差别的字符表，另外单列了对空格的转义情况。解码测试使用全部特殊字符转义的字符串，由于解码结果均相同，不额外展示在表格中。</p>
<table>
<thead>
<tr>
<th>语言</th>
<th>Module / Function</th>
<th style="text-align: center;"><code>sub-delims</code><br/> 未被转义</th>
<th style="text-align: center;"><code>unreserved</code> <br/>被转义</th>
<th style="text-align: center;">SP 编码</th>
<th style="text-align: center;"><code>+</code> 解码</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python 3</td>
<td><code>urllib.parse</code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><code>+</code></td>
<td style="text-align: center;">需使用 <code>unquote_plus</code></td>
</tr>
<tr>
<td>Go</td>
<td><code>net/url</code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><code>+</code></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td>Java</td>
<td><code>java.net.URLEncoder</code> <br/> <code>java.net.URLDecoder</code></td>
<td style="text-align: center;"><code>*</code></td>
<td style="text-align: center;"><code>~</code></td>
<td style="text-align: center;"><code>+</code></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td>JavaScript</td>
<td><code>URLSearchParams</code></td>
<td style="text-align: center;"><code>*</code></td>
<td style="text-align: center;"><code>~</code></td>
<td style="text-align: center;"><code>+</code></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td>JavaScript</td>
<td><code>encodeURIComponent</code><br/> <code>decodeURIComponent</code></td>
<td style="text-align: center;"><code>*</code></td>
<td style="text-align: center;"><code>~</code></td>
<td style="text-align: center;"><code>%20</code></td>
<td style="text-align: center;">无法解码 <code>+</code></td>
</tr>
<tr>
<td>Node.js</td>
<td><code>querystring</code></td>
<td style="text-align: center;"><code>!'()*</code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><code>%20</code></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td>C#</td>
<td><code>System.Net.WebUtility</code></td>
<td style="text-align: center;"><code>!()*</code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><code>+</code></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td>PHP</td>
<td><code>urlencode</code> <br/> <code>urldecode</code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><code>~</code></td>
<td style="text-align: center;"><code>+</code></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td>PHP</td>
<td><code>rawurlencode</code><br/> <code>rawurldecode</code></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><code>%20</code></td>
<td style="text-align: center;">无法解码 <code>+</code></td>
</tr>
</tbody>
</table>
<p>虽然编码时对符号的转义处理不同，但是使用全部转义的 <code>sub-delims</code> 以及 <code>unreserved</code> 中的特殊字符进行测试时被测程序都能正确进行解码。</p>
<h2>测试代码</h2>
<p>Python 3:</p>
<pre class="highlight"><code class="language-python">from urllib.parse import urlencode, unquote, unquote_plus

print(urlencode({&quot;param&quot;:&quot; !$&amp;'()*+,;=-._~&quot;}))
print(unquote(&quot;param=a+b&quot;))
print(unquote_plus(&quot;param=a+b&quot;))
</code></pre>

<pre class="highlight"><code class="language-text">param=+%21%24%26%27%28%29%2A%2B%2C%3B%3D-._~
param=a+b
param=a b
</code></pre>

<p>Go:</p>
<pre class="highlight"><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;net/url&quot;
)

func main() {
    fmt.Println(url.QueryEscape(&quot; !$&amp;'()*+,;=-._~&quot;))
    fmt.Println(url.QueryUnescape(&quot;a+b&quot;))
}
</code></pre>

<pre class="highlight"><code class="language-text">+%21%24%26%27%28%29%2A%2B%2C%3B%3D-._~
a b &lt;nil&gt;
</code></pre>

<p>Java:</p>
<pre class="highlight"><code class="language-java">import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;

public class Main {
    public static void main(String[] args) throws UnsupportedEncodingException {
        System.out.println(URLEncoder.encode(&quot; !$&amp;'()*+,;=-._~&quot;, StandardCharsets.UTF_8.toString()));
        System.out.println(URLDecoder.decode(&quot;a+b&quot;, StandardCharsets.UTF_8.toString()));
    }
}
</code></pre>

<pre class="highlight"><code class="language-text">+%21%24%26%27%28%29*%2B%2C%3B%3D-._%7E
a b
</code></pre>

<p>JavaScript:</p>
<pre class="highlight"><code class="language-js">const encode = new URLSearchParams();
encode.set(&quot;param&quot;, &quot; !$&amp;'()*+,;=-._~&quot;);
console.log(encode.toString());
const decode = new URLSearchParams(&quot;param=a+b&quot;);
console.log(decode.get(&quot;param&quot;));
console.log(encodeURIComponent(&quot; !$&amp;'()*+,;=-._~&quot;));
console.log(decodeURIComponent(&quot;a+b&quot;));
</code></pre>

<pre class="highlight"><code class="language-text">param=+%21%24%26%27%28%29*%2B%2C%3B%3D-._%7E
a b
%20!%24%26'()*%2B%2C%3B%3D-._~
a+b
</code></pre>

<p>Node.js:</p>
<pre class="highlight"><code class="language-js">const querystring = require(&quot;querystring&quot;);
console.log(querystring.stringify({ param: &quot; !$&amp;'()*+,;=-._~&quot; }));
console.log(querystring.parse(&quot;param=a+b&quot;).param);
</code></pre>

<pre class="highlight"><code class="language-text">param=%20!%24%26'()*%2B%2C%3B%3D-._~
a b
</code></pre>

<p>C#:</p>
<pre class="highlight"><code class="language-cs">using System;

class Program
{
    static void Main()
    {
        Console.WriteLine(System.Net.WebUtility.UrlEncode(&quot; !$&amp;'()*+,;=-._~&quot;));
        Console.WriteLine(System.Net.WebUtility.UrlDecode(&quot;a+b&quot;));
    }
}
</code></pre>

<pre class="highlight"><code class="language-text">+!%24%26%27()*%2B%2C%3B%3D-._%7E
a b
</code></pre>

<p>PHP:</p>
<pre class="highlight"><code class="language-php">&lt;?php
echo urlencode(&quot; !$&amp;'()*+,;=-._~&quot;) . &quot;\n&quot;;
echo urldecode(&quot;a+b&quot;) . &quot;\n&quot;;
echo rawurlencode(&quot; !$&amp;'()*+,;=-._~&quot;) . &quot;\n&quot;;
echo rawurldecode(&quot;a+b&quot;) . &quot;\n&quot;;
?&gt;
</code></pre>

<pre class="highlight"><code class="language-text">+%21%24%26%27%28%29%2A%2B%2C%3B%3D-._%7E
a b
%20%21%24%26%27%28%29%2A%2B%2C%3B%3D-._~
a+b
</code></pre>]]></description>
      <guid isPermaLink="false">https://xiaohei.moe/post/2023/08/07/url-encode-differentiation/</guid>
      <pubDate>Mon, 07 Aug 2023 20:00:00 +0806</pubDate>
    </item>
    <item>
      <title>NoneBot QQ 机器人开发指南</title>
      <link>https://xiaohei.moe/post/2023/10/21/nonebot-qq-bot-development/</link>
      <description><![CDATA[<p><a href="https://q.qq.com/#/">QQ 开放平台</a> 近期将把之前已经用于频道的 <a href="https://bot.q.qq.com/wiki">QQ 机器人</a> 扩展到群聊和私聊场景。虽然功能限制较多，但由于其是官方 API，稳定性会比较好。本篇文章为使用 NoneBot 开发 QQ 机器人的教程，阅读本教程需要有一定 Python 开发基础。需要注意，本教程仅为相关文档的补充，请仔细阅读文中引用的文档。</p>
<h2>前期准备</h2>
<h3>了解机器人能力</h3>
<p>QQ 机器人应用于频道和群聊两个主要场景，可以在单聊、群聊、文字子频道、频道私信使用，提供的频道机器人能力可以参考 <a href="https://bot.q.qq.com/wiki/develop/api/">API 文档</a>；群聊机器人能力暂未公开发布，可先参考 <a href="https://docs.qq.com/doc/DRkVHT1N2a1JYSnVr">QQ Bot 开发者文档【内测版】</a>。</p>
<p>需要注意的限制有：</p>
<ul>
<li>发送消息文本中的链接需要经过 ICP 备案，并在 QQ 机器人管理端进行根目录文件验证绑定。其他含有格式为 <code>英文.英文</code> 的文本也无法发送，如 <code>bot.self_id</code>，可以考虑将 <code>.</code> 替换为其他符号。</li>
<li>无法在群聊和文字子频道接收图片和视频。</li>
<li>无法在文字子频道和频道私信收发语音和文件，无法在群聊接收语音和文件。</li>
<li>所有群管理能力暂不对外开放。</li>
</ul>
<h3>创建沙箱频道</h3>
<p>当前 QQ 机器人需要在沙箱频道中进行测试，请确保所使用的开发者 QQ 账号拥有 QQ 频道内测权限，并创建一个频道供机器人测试使用，并确保该频道人数小于 20 人。</p>
<h3>私域机器人</h3>
<p>公域 QQ 机器人只能响应 @机器人 后发送的消息，而频道私域机器人可以响应全量的文字子频道消息，并有额外的频道管理能力（群机器人目前只有公域）。如果想要创建不需要 @机器人 的频道私域机器人，请确保使用频道主的账号进行 QQ 开放平台的注册，并在创建机器人时选择类型为“私域”。</p>
<p>频道私域机器人额外能力：获取频道成员列表、删除指定频道成员、创建子频道、修改子频道信息、删除指定子频道、可以接收频道内发送的所有消息事件。</p>
<h2>QQ 机器人介绍与开通</h2>
<p>想要接入 QQ 机器人，首先需要在 QQ 开放平台进行注册，具体流程请查看 QQ 机器人文档的 <a href="https://bot.q.qq.com/wiki/#%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B">接入流程</a> 部分，可以使用企业或个人主体入驻（文档中第 2 步或第 3 步）。</p>
<p>完成开发者账号创建后，登录 <a href="https://q.qq.com/#/app/bot">QQ 开放平台</a> 参考 接入流程 文档的第 4 步创建应用，在 “应用管理” → “机器人” 标签下点击 “创建机器人” 按钮。</p>
<p>成功创建机器人后在 <a href="https://q.qq.com/bot/#/developer/developer-setting">开发设置</a> 界面获取机器人的 BotAppID、机器人令牌、机器人密钥。</p>
<h2>NoneBot 项目创建与配置</h2>
<p>本文中的 NoneBot 均指 NoneBot2。NoneBot2 是一个可扩展的 Python 异步机器人框架，它会对机器人收到的事件进行解析和处理，并以插件化的形式，按优先级分发给事件所对应的事件响应器，来完成具体的功能。</p>
<h3>测试项目创建</h3>
<p>如果未使用过 NoneBot，建议首先创建一个测试用的 Bot 工程以熟悉项目创建流程。</p>
<p>参考 NoneBot 文档的 <a href="https://nonebot.dev/docs/quick-start">快速上手</a> 章节创建一个基于终端的交互式机器人实例，并测试是否正常工作。</p>
<h3>项目创建与配置</h3>
<p>上述测试成功后便可以创建开发 QQ 机器人使用的工程，命令行跳转到放置工程的目录，按照上述 快速上手 章节中 创建项目 部分的操作步骤，项目模板 选择 <code>simple（插件开发者）</code>，并按下面的内容选择驱动器和适配器：</p>
<pre class="highlight"><code>[?] 要使用哪些驱动器? HTTPX (HTTPX 驱动器), websockets (websockets 驱动器)
[?] 要使用哪些适配器? QQ (QQ 官方机器人)
</code></pre>

<p>完成项目创建后，参考 <a href="https://github.com/nonebot/adapter-qq">QQ 适配器文档</a> 进行 QQ 适配器配置，打开项目目录下的 <code>.env</code> 文件（如果没有这个文件，请在创建时选择 <code>simple</code> 模板），添加以下内容：</p>
<pre class="highlight"><code>QQ_IS_SANDBOX=true
QQ_BOTS='
[
  {
    &quot;id&quot;: &quot;xxx&quot;,
    &quot;token&quot;: &quot;xxx&quot;,
    &quot;secret&quot;: &quot;xxx&quot;,
    &quot;intent&quot;: {
      &quot;guild_messages&quot;: true,
      &quot;at_messages&quot;: false
    }
  }
]
'
</code></pre>

<p>将 <code>id</code> <code>token</code> <code>secret</code> 分别替换为在 QQ 开放平台获取到的 BotAppID、机器人令牌、机器人密钥。</p>
<p>以上配置为频道私域机器人，接收全量消息无需 @机器人，如果使用频道公域机器人，将 <code>guild_messages</code> 值改为 <code>false</code>，<code>at_messages</code> 值改为 <code>false</code>，或删去这两个配置项使用默认值。</p>
<p>完成以上配置后，运行机器人项目，在沙箱频道中 @机器人 并输入 <code>/echo hello world</code> 测试，如果收到回复则配置成功（此处需要 @机器人 是因为 <code>echo</code> 插件只接受与我相关的消息，文字子频道中需要 @机器人 触发）。</p>
<h2>插件开发</h2>
<h3>插件编写基础</h3>
<p>参考 NoneBot 文档中的 <a href="https://nonebot.dev/docs/tutorial/create-plugin">插件编写准备</a>、<a href="https://nonebot.dev/docs/tutorial/matcher">事件响应器</a>、<a href="https://nonebot.dev/docs/tutorial/handler">事件处理</a>、<a href="https://nonebot.dev/docs/tutorial/event-data">获取事件信息</a> 四个部分进行示例插件的创建。</p>
<p>按照文档创建的插件是可以提供给任何适配器使用的，所以也适用于 QQ 适配器。这种方式的局限性在于无法适用适配器提供的特殊消息类型，而只能发送纯文本，要实现发送图片之类的功能，则需要根据所使用的适配器对发送的消息进行处理。</p>
<h3>QQ 适配器消息处理</h3>
<p>参考 NoneBot 文档中的 <a href="https://nonebot.dev/docs/tutorial/message">处理消息</a> 部分，文档中是以 <code>Console</code> 适配器作为示例，与 QQ 适配器有部分不同，QQ 适配器中提供了以下消息段：</p>
<ul>
<li><code>MessageSegment.text("abc")</code>: 文本消息段。</li>
<li><code>MessageSegment.emoji("4")</code>: QQ 表情，ID 参考 QQ 机器人文档的 <a href="https://bot.q.qq.com/wiki/develop/api/openapi/emoji/model.html">表情对象</a> 部分。</li>
<li><code>MessageSegment.mention_user("12345")</code>: 提及 @用户。</li>
<li><code>MessageSegment.mention_channel("123")</code>: 提及 #子频道。</li>
<li><code>MessageSegment.mention_everyone()</code>: 提及 @所有人。</li>
<li><code>MessageSegment.image("http://example.com/image.png")</code>: 网络图片，需要后台绑定域名。</li>
<li><code>MessageSegment.MessageSegment.file_image(image)</code>: 本地图片，可以传入 <code>bytes</code> / <code>io.BytesIO</code> / <code>pathlib.Path</code>。</li>
<li><code>MessageSegment.ark(ark)</code>: Ark 消息，私域被动消息有 Ark 权限，参考 QQ 机器人文档的 <a href="https://bot.q.qq.com/wiki/develop/api/openapi/message/post_ark_messages.html">发送 ARK 模板消息</a> 部分。</li>
<li><code>MessageSegment.embed(embed)</code>: Embed 消息，<a href="https://bot.q.qq.com/wiki/develop/api/openapi/message/template/embed_message.html">文档</a>。</li>
<li><code>MessageSegment.markdown(markdown)</code>: Markdown 模板消息和 Markdown 消息，需要内邀开通，<a href="https://bot.q.qq.com/wiki/develop/api/openapi/message/post_markdown_messages.html">文档</a>。</li>
<li><code>MessageSegment.keyboard(keyboard)</code>: Markdown 消息的按钮列表，需要内邀开通，<a href="https://bot.q.qq.com/wiki/develop/api/openapi/message/message_keyboard.html">文档</a>。</li>
</ul>
<p>使用以上消息段进行消息拼接，便可以使用 QQ 适配器的特有消息类型进行消息发送和回复。以 NoneBot 文档中的插件示例为例，可以修改为：</p>
<pre class="highlight"><code class="language-python">from nonebot import on_command
from nonebot.rule import to_me
from nonebot.adapters import Message
from nonebot.params import CommandArg

# 文件系统路径 Python 标准库
# 用于创建本地文件路径
from pathlib import Path

# 从 QQ 适配器导入消息段
from nonebot.adapters.qq import MessageSegment

weather = on_command(
    &quot;天气&quot;, rule=to_me(), aliases={&quot;weather&quot;, &quot;查天气&quot;}, priority=10, block=True
)

@weather.handle()
async def handle_function(args: Message = CommandArg()):
    # 提取参数纯文本作为地名，并判断是否有效
    if location := args.extract_plain_text():
        image = Path(&quot;data/image.png&quot;)
        messaege = f&quot;今天{location}的天气是...&quot; + MessageSegment.file_image(image)
        await weather.finish(messaege)
    else:
        messaege = MessageSegment.emoji(&quot;123&quot;) + &quot;请输入地名&quot;
        await weather.finish(messaege)
</code></pre>

<h3>QQ 适配器 API 调用</h3>
<p>QQ 适配器提供了 API 的封装，可以直接使用 Bot 实例进行调用，QQ 适配器中提供的 API 可在 <a href="https://bot.q.qq.com/wiki/develop/api/">API 文档</a> 中查看，推荐使用输入关键词加上自动补全（如使用 Visual Studio Code 的 Pylance 扩展）来快速找到对应的 API 封装名称和参数列表，示例如下：</p>
<pre class="highlight"><code class="language-python">from nonebot import on_command
from nonebot.adapters.qq import Bot, MessageCreateEvent

test = on_command(&quot;test&quot;)

@test.handle()
async def handle_function(bot: Bot, event: MessageCreateEvent):
    guild = await bot.get_guild(guild_id=event.guild_id)
    member = await bot.get_member(guild_id=guild.id, user_id=event.get_user_id())
    await test.finish(member.json())
</code></pre>

<p>更加深入的开发请参考 <a href="https://nonebot.dev/docs">NoneBot 文档</a>。</p>]]></description>
      <guid isPermaLink="false">https://xiaohei.moe/post/2023/10/21/nonebot-qq-bot-development/</guid>
      <pubDate>Sat, 21 Oct 2023 17:15:00 +0806</pubDate>
    </item>
    <follow-challenge>
      <feedId>54860944275961856</feedId>
      <userId>52323271612923904</userId>
    </follow-challenge>
  </channel>
</rss>
